import numpy as np
import matplotlib.pyplot as plt
from time import sleep
import matplotlib.patches as patches
from ex2 import simple_rounding, orth_proj, Gram_Schmidt_orth, nearest_plane
from generic_functions import generate_lattice_points, in_lattice
import math
from itertools import product

# The exercises comprises of function to be implemented: replace the keyword "pass"
# with your implementation.

############
# Exercise 1
# Enumerate lattice vectors in a bounding box
############

def enumeration(x, r):
    """
    Return all integer vectors in Z^n whose coordinates differ from `x`
    by at most `r` (per coordinate).

    :param t: A NumPy array representing the vector `x`.
    :type t: numpy.ndarray
    :param l: An integer or float representing the distance `r`.
    :type l: int or float

    :return: A list of lattice vectors in Z^n whose coordinates are
    within distance `r` (per coordinate) from `x`.
    :rtype: list of numpy.ndarray

    :notes: Make use of itertools product function
    and the built-in append function.
    """
    s = math.floor(r)
    m = np.zeros((x.shape[0],2*s+1), dtype=int)
    v = np.zeros(x.shape, dtype=int)
    y = np.zeros((1, 2*s+1), dtype=int)
    list = []
    for i in range(x.shape[0]):
        for j in range(2*s+1):
            m[i,j] = x[i]-s+j
    for i in range(2*s+1):
        y[0,i] = i
    for w in product(y[0], repeat=x.shape[0]):
        for i in range(x.shape[0]):
            v[i] = m[i,w[i]]
        t = v.copy()
        list.append(t)
    return list



############
# Exercise 2
# Implement the Simple Enumeration Algorithm 
############

def simple_enumeration(B, t, l):
    """
	Return a lattice vector close to the target vector `t`, using the Simple Enumeration algorithm.

	:param B: A square (n x n) NumPy array representing a lattice basis.
	:type B: numpy.ndarray
	:param t: A NumPy array representing the target vector to approximate with a lattice point.
	:type t: numpy.ndarray
	:param l: An integer value representing the fundamental domain scaling.
	:type l: int

	:return: A lattice vector in the lattice generated by `B` that is close to `t`.
	:rtype: numpy.ndarray

	:notes: Make use of previously implemented function enumeration, as well ass
    numpy.linalg functions solve and norm and numpy function round.
	"""
    # Initialize the best lattice vector found so far
    c = np.ndarray(t.shape, dtype=int)
    c.fill(np.iinfo(int).max)

    BT = np.transpose(B)
    c = np.zeros(t.shape)
    tprime = np.linalg.inv(np.transpose(B)) @ t
    for vprime in enumeration(tprime, l/2):
        v = BT @ vprime
        if (v-t)@(v-t) < (c-t)@(c-t):
            c = v
    return c

############
# Exercise 3
# Implement the Fincke-Pohst Enumeration Subroutine
############

def fincke_pohst_1d_enumeration(b1, x, t, r):
    """
    Enumerate all lattice points along the line spanned by the basis vector `b1`
    that lie within a Euclidean distance `r` from the target vector `t`.

    :param b1: The first basis vector of the lattice, given in Euclidean coordinates.
    :type b1: numpy.ndarray
    :param x: The current partial lattice vector (from higher dimensions) in Euclidean coordinates.
    :type x: numpy.ndarray
    :param t: The target vector in Euclidean coordinates.
    :type t: numpy.ndarray
    :param r: Search radius. Only lattice points within distance `r` from `t` are enumerated.
    :type r: float

    :return: A list of lattice points (NumPy arrays) along the `b1` direction 
             that satisfy the radius constraint.
    :rtype: list[numpy.ndarray]
    """
    liosta = []
    j = ((x - t) @ b1) / (b1 @ b1)
    floor = -math.floor(j)
    h = 0
    l = 0
    while ((j + floor + h) * (b1)) @ ((j + floor + h) * (b1)) <= r ** 2:
        liosta.append((floor + h) * b1)
        h = h + 1
    while ((j + floor - l - 1) * b1) @ ((j + floor - l - 1) * b1) <= r ** 2:
        liosta.append((floor - l - 1) * b1)
        l = l + 1
    return liosta


############
# Exercise 4
# Implement the Fincke-Pohst Enumeration Algorithm
############

def fincke_pohst_enumeration(B, t, r):
    """
    Enumerate all lattice vectors within distance `r` from `t`
    in the lattice defined by basis `B`.

    :param B: A square (n x n) NumPy array representing a lattice basis (rows are basis vectors).
    :type B: numpy.ndarray
    :param t: A NumPy array representing the target vector to approximate with a lattice point.
    :type t: numpy.ndarray
    :param r: An integer or float representing the search radius.
    :type r: int or float

    :return: A list of lattice vectors within the specified distance from `t`.
    :rtype: list[numpy.ndarray]

    :notes: Make use of np.linalg.lstsq (i.e. the least-square method) or np.linalg.pinv
    for matrix pseudo inversion.
    """
    if B.shape[0] == 1:
        x = np.zeros(t.shape)
        return fincke_pohst_1d_enumeration(B[0], x, t, r)
    S = []
    Bprime = np.zeros((B.shape[0] - 1, B.shape[1]))
    for i in range(B.shape[0] - 1):
        Bprime[i] = B[i + 1] - orth_proj(B[i + 1], B[0])
    Sprime = fincke_pohst_enumeration(Bprime, t - orth_proj(t, B[0]), r)
    for elt in Sprime:
        print("elt=", elt)
        rho = r ** 2 - elt @ elt  # originally we would have to take the square root
        print("rho=", rho)
        print("pseudoinv=", np.linalg.pinv(Bprime))
        y = np.linalg.pinv(Bprime) @ np.transpose(elt)
        print("y=", y)
        z = np.array([0])
        yprime = np.concatenate((z, y), axis=None)
        print(yprime)
        x = B @ yprime
        print(x)
        h = 0
        l = 0
        j = ((x - t) @ B[0]) / (B[0] @ B[0])
        while ((j + h) * (B[0])) @ ((j + h) * (B[0])) <= rho ** 2:
            S.append(x + h * B[0])
            h = h + 1
        while ((j - l - 1) * B[0]) @ ((j - l - 1) * B[0]) <= rho ** 2:
            S.append(x + (-l - 1) * B[0])
            l = l + 1
    return S

    

############
# Helper functions
############

def draw_basis_vectors(B):
    """
    Draw basis vectors.

    Parameters
    ----------
    B : np.ndarray
        2×2 basis matrix (rows are basis vectors).
    """
    b1 = B[0, :]
    b2 = B[1, :]

    arrow_style = dict(
        head_width=0.3,
        head_length=0.3,
        fc="blue", ec="blue",
        length_includes_head=True
    )

    plt.arrow(0, 0, b1[0], b1[1], **arrow_style)
    plt.arrow(0, 0, b2[0], b2[1], **arrow_style)


def draw_fundamental_regions(B, xlim, ylim, color1="lightgray", color2="white", alpha=0.8, outline=True):
    """
    Draw checkerboard-style centered fundamental parallelograms over the given bounds.

    Parameters
    ----------
    B : np.ndarray
        2×2 basis matrix (rows are basis vectors).
    xlim, ylim : tuple
        Horizontal and vertical plot limits in Euclidean coords.
    """
    B = np.asarray(B, dtype=float)

    # Basis vectors (rows)
    b1 = B[0, :]
    b2 = B[1, :]

    # Offsets for the centered fundamental region: ±½ b1 ± ½ b2 (closed loop)
    offsets = np.vstack([
        -0.5*b1 - 0.5*b2,
         0.5*b1 - 0.5*b2,
         0.5*b1 + 0.5*b2,
        -0.5*b1 + 0.5*b2,
        -0.5*b1 - 0.5*b2
    ])

    # Map plot-box corners to lattice coordinates
    box = np.array([
        [xlim[0], ylim[0]],
        [xlim[0], ylim[1]],
        [xlim[1], ylim[0]],
        [xlim[1], ylim[1]],
    ], dtype=float)

    # lattice coords of the 4 corners: solve [i,j] @ B = [x,y]
    box_lat = np.linalg.solve(B.T, box.T).T
    i_min = int(np.floor(box_lat[:, 0].min())) - 1
    i_max = int(np.ceil (box_lat[:, 0].max())) + 1
    j_min = int(np.floor(box_lat[:, 1].min())) - 1
    j_max = int(np.ceil (box_lat[:, 1].max())) + 1

    # Tile cells
    for i in range(i_min, i_max + 1):
        for j in range(j_min, j_max + 1):
            # Center of this cell in Euclidean coordinates
            center = np.array([i, j]) @ B

            # Alternate fill by parity in lattice coords
            color = color1 if ((i + j) % 2 == 0) else color2

            poly = center + offsets
            plt.fill(poly[:, 0], poly[:, 1], color=color, alpha=alpha, zorder=0)
            if outline:
                plt.plot(poly[:, 0], poly[:, 1], color="gray", linewidth=0.6, zorder=1)


############
# Demo runner
############

def run_lattice_demo(B, t, l):
    print(f"\n=== Running for Basis:\n{B} ===")
    print("Target vector:", t)

    # Simple rounding
    print("\nRunning simple rounding...")
    rounding_vec = simple_rounding(B, t)
    print("Closest lattice vector (rounding):", rounding_vec)

    # Simple enumeration
    print("\nRunning simple enumeration...")
    simple_enum_vec = simple_enumeration(B, t, l)
    print("Closest lattice vector (enumeration):", simple_enum_vec)

    # Fincke-Phost enumeration
    Bs = Gram_Schmidt_orth(B)
    x = nearest_plane(B, Bs, t)
    # r = 12
    r = np.linalg.norm(x - t)

    print("\nRunning Fincke-Phost enumeration...")
    fincke_pohst_enum_vec = fincke_pohst_enumeration(B, t, r)
    fincke_pohst_enum_vec_min = min(fincke_pohst_enum_vec, key=lambda v: np.linalg.norm(np.array(v) - t))
    print("Closest lattice vector (Fincke-Phost enumeration):", fincke_pohst_enum_vec_min)

    # Determine plotting bounds dynamically from all lattice coordinates
    all_x = np.concatenate([
        [0, t[0], rounding_vec[0], simple_enum_vec[0]] + [v[0] for v in fincke_pohst_enum_vec]
    ])
    all_y = np.concatenate([
        [0, t[1], rounding_vec[1], simple_enum_vec[1]] + [v[1] for v in fincke_pohst_enum_vec]
    ])

    margin = 5
    x_min = np.min(all_x) - margin
    x_max = np.max(all_x) + margin
    y_min = np.min(all_y) - margin
    y_max = np.max(all_y) + margin

    # Generate lattice in computed bounds
    xlim = (x_min, x_max)
    ylim = (y_min, y_max)
    lattice_vecs = generate_lattice_points(B, xlim, ylim)

    # Plot 1
    plt.clf()
    plt.scatter(lattice_vecs[:, 0], lattice_vecs[:, 1], c="black", label="Lattice Points")
    plt.scatter(t[0], t[1], c="red", marker="x", s=50, label="Target")
    plt.scatter(rounding_vec[0], rounding_vec[1], c="orange", label="Simple Rounding Result")
    plt.scatter(simple_enum_vec[0], simple_enum_vec[1], c="green", label="Simple Enumeration Result")
    draw_basis_vectors(B)
    draw_fundamental_regions(B, xlim, ylim)
    plt.xlim(x_min, x_max)
    plt.ylim(y_min, y_max)
    plt.legend(loc='upper center', bbox_to_anchor=(0.5, -0.1), ncol=2)
    plt.title(f"Enumerated Region (Basis:\n{B})")
    plt.tight_layout()
    plt.show()

    sleep(1)
    

    # Plot 2
    plt.clf()
    plt.scatter(lattice_vecs[:, 0], lattice_vecs[:, 1], c="black", label="Lattice Points")
    plt.scatter(t[0], t[1], c="red", marker="x", s=50, label="Target")
    circle = patches.Circle((t[0], t[1]), r, fill=False, color="blue", linestyle="--", label=f"Radius {r:.2f}")
    plt.gca().add_patch(circle)
    #plt.gca().set_aspect('equal', adjustable='box')
    for i, fp in enumerate(fincke_pohst_enum_vec):
        if i == 0:
            plt.scatter(fp[0], fp[1], c="magenta", label="Fincke-Phost Enumeration Result")
        else:
            plt.scatter(fp[0], fp[1], c="magenta")
    #plt.scatter(fincke_pohst_enum_vec_min[0], fincke_pohst_enum_vec_min[1], c="cyan", label="Fincke-Phost Enumeration Result")
    draw_basis_vectors(B)
    draw_fundamental_regions(B, xlim, ylim)
    plt.xlim(x_min, x_max)
    plt.ylim(y_min, y_max)
    plt.legend(loc='upper center', bbox_to_anchor=(0.5, -0.1), ncol=2)
    plt.title(f"Enumerated Region (Basis:\n{B})")
    plt.tight_layout()
    plt.show()

############
# Main runner
############
if __name__ == "__main__":

    # Diameter
    l = 4

    # Example bases
    bases = [
        np.array([[4, 0], [1, 4]], dtype=int),     # Pretty orthogonal basis
        np.array([[4, 4], [5, 8]], dtype=int)      # Stretched along x-axis
    ]

    # Target vector
    t = np.array([3.3, 8.4], dtype=float)

    # Run the demo for each basis
    for B in bases:
        run_lattice_demo(B, t, l)

