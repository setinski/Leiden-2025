import numpy as np
import matplotlib.pyplot as plt
from time import sleep
import matplotlib.patches as patches
import itertools
import math
from sol2 import simple_rounding, orth_proj, Gram_Schmidt_orth, nearest_plane
from generic_functions import generate_lattice_points, in_lattice

# The exercises comprises of function to be implemented: replace the keyword "pass"
# with your implementation.

############
# Exercise 1
# Enumerate lattice vectors in a bounding box
############

def enumeration(x, r):
    n=len(x)

    if n==0:
        return [np.array([], dtype=int)]
    ranges = []

    for i in range(n):
        high = int(np.floor(x[i] + r)+1)  
        low = int(np.ceil(x[i] - r)) 
        ranges.append(range(low, high))

    result=[]
    for point in itertools.product(*ranges):
        result.append(np.array(point))
    return result
    """
    Return all integer vectors in Z^n whose coordinates differ from `x`
    by at most `r` (per coordinate).

    :param t: A NumPy array representing the vector `x`.
    :type t: numpy.ndarray
    :param l: An integer or float representing the distance `r`.
    :type l: int or float

    :return: A list of lattice vectors in Z^n whose coordinates are
    within distance `r` (per coordinate) from `x`.
    :rtype: list of numpy.ndarray

    :notes: Make use of itertools product function
    and the built-in append function.
    """

############
# Exercise 2
# Implement the Simple Enumeration Algorithm 
############

def simple_enumeration(B, t, l):
    # Initialize the best lattice vector found so far
    c = np.ndarray(t.shape, dtype=int)
    c.fill(np.iinfo(int).max)

    t_new=t @ np.linalg.inv(B)
    enum=enumeration(t_new, l/2)

    assert enum, "Enumeration returned None, expected a list of vectors."
    
    for v_temp in enum:
        v=v_temp@B
        if np.linalg.norm(v-t)< np.linalg.norm(c-t):
            c=v
    return c
    """
	Return a lattice vector close to the target vector `t`, using the Simple Enumeration algorithm.

	:param B: A square (n x n) NumPy array representing a lattice basis.
	:type B: numpy.ndarray
	:param t: A NumPy array representing the target vector to approximate with a lattice point.
	:type t: numpy.ndarray
	:param l: An integer value representing the fundamental domain scaling.
	:type l: int

	:return: A lattice vector in the lattice generated by `B` that is close to `t`.
	:rtype: numpy.ndarray

	:notes: Make use of previously implemented function enumeration, as well ass
    numpy.linalg functions solve and norm and numpy function round.
	"""

############
# Exercise 3
# Implement the Fincke-Pohst Enumeration Subroutine
############

def fincke_pohst_1d_enumeration(b1, x, t, r):
    result=[]
    maxdistance=r/np.linalg.norm(b1)
    t_new=x-t
    proj=(t_new@b1)/(b1@b1)
    high = int(np.floor(maxdistance-proj)+1)  
    low = int(np.ceil(-maxdistance-proj)) 
    ranges=range(low, high)

    for z in ranges:
        pt=b1*z+t_new
        result.append(np.array(pt))
    return result

    """
    Enumerate all lattice points along the line spanned by the basis vector `b1`
    that lie within a Euclidean distance `r` from the target vector `t`.

    :param b1: The first basis vector of the lattice, given in Euclidean coordinates.
    :type b1: numpy.ndarray
    :param x: The current partial lattice vector (from higher dimensions) in Euclidean coordinates.
    :type x: numpy.ndarray
    :param t: The target vector in Euclidean coordinates.
    :type t: numpy.ndarray
    :param r: Search radius. Only lattice points within distance `r` from `t` are enumerated.
    :type r: float

    :return: A list of lattice points (NumPy arrays) along the `b1` direction 
             that satisfy the radius constraint.
    :rtype: list[numpy.ndarray]
    """


############
# Exercise 4
# Implement the Fincke-Pohst Enumeration Algorithm
############

def fincke_pohst_enumeration(B, t, r):
    n=B.shape[0]
    b1=B[0,:]
    if n==1:
        return fincke_pohst_1d_enumeration(b1, 0, t, r)

    S=[]
    Bprime=np.zeros((n-1, n))
    for i in range(Bprime.shape[0]):
        Bprime[i]=B[i+1]-orth_proj(B[i+1], b1)
    S_temp=fincke_pohst_enumeration(Bprime, orth_proj(t,b1), r)
    for s in S_temp:
        rho=math.sqrt(r**2-np.linalg.norm(s-(t-orth_proj(t,b1)))**2)
        y=np.linalg.pinv(Bprime)@s
        x=y @ B[1:]
        Z=fincke_pohst_1d_enumeration(b1, x, t, rho)
        if Z:
            S.extend(Z)
    return S
    """
    Enumerate all lattice vectors within distance `r` from `t`
    in the lattice defined by basis `B`.

    :param B: A square (n x n) NumPy array representing a lattice basis (rows are basis vectors).
    :type B: numpy.ndarray
    :param t: A NumPy array representing the target vector to approximate with a lattice point.
    :type t: numpy.ndarray
    :param r: An integer or float representing the search radius.
    :type r: int or float

    :return: A list of lattice vectors within the specified distance from `t`.
    :rtype: list[numpy.ndarray]

    :notes: Make use of np.linalg.lstsq (i.e. the least-square method) or np.linalg.pinv
    for matrix pseudo inversion.
    """


############
# Helper functions
############

def draw_basis_vectors(B):
    """
    Draw basis vectors.

    Parameters
    ----------
    B : np.ndarray
        2×2 basis matrix (rows are basis vectors).
    """
    b1 = B[0, :]
    b2 = B[1, :]

    arrow_style = dict(
        head_width=0.3,
        head_length=0.3,
        fc="blue", ec="blue",
        length_includes_head=True
    )

    plt.arrow(0, 0, b1[0], b1[1], **arrow_style)
    plt.arrow(0, 0, b2[0], b2[1], **arrow_style)


def draw_fundamental_regions(B, xlim, ylim, color1="lightgray", color2="white", alpha=0.8, outline=True):
    """
    Draw checkerboard-style centered fundamental parallelograms over the given bounds.

    Parameters
    ----------
    B : np.ndarray
        2×2 basis matrix (rows are basis vectors).
    xlim, ylim : tuple
        Horizontal and vertical plot limits in Euclidean coords.
    """
    B = np.asarray(B, dtype=float)

    # Basis vectors (rows)
    b1 = B[0, :]
    b2 = B[1, :]

    # Offsets for the centered fundamental region: ±½ b1 ± ½ b2 (closed loop)
    offsets = np.vstack([
        -0.5*b1 - 0.5*b2,
         0.5*b1 - 0.5*b2,
         0.5*b1 + 0.5*b2,
        -0.5*b1 + 0.5*b2,
        -0.5*b1 - 0.5*b2
    ])

    # Map plot-box corners to lattice coordinates
    box = np.array([
        [xlim[0], ylim[0]],
        [xlim[0], ylim[1]],
        [xlim[1], ylim[0]],
        [xlim[1], ylim[1]],
    ], dtype=float)

    # lattice coords of the 4 corners: solve [i,j] @ B = [x,y]
    box_lat = np.linalg.solve(B.T, box.T).T
    i_min = int(np.floor(box_lat[:, 0].min())) - 1
    i_max = int(np.ceil (box_lat[:, 0].max())) + 1
    j_min = int(np.floor(box_lat[:, 1].min())) - 1
    j_max = int(np.ceil (box_lat[:, 1].max())) + 1

    # Tile cells
    for i in range(i_min, i_max + 1):
        for j in range(j_min, j_max + 1):
            # Center of this cell in Euclidean coordinates
            center = np.array([i, j]) @ B

            # Alternate fill by parity in lattice coords
            color = color1 if ((i + j) % 2 == 0) else color2

            poly = center + offsets
            plt.fill(poly[:, 0], poly[:, 1], color=color, alpha=alpha, zorder=0)
            if outline:
                plt.plot(poly[:, 0], poly[:, 1], color="gray", linewidth=0.6, zorder=1)


############
# Demo runner
############

def run_lattice_demo(B, t, l):
    print(f"\n=== Running for Basis:\n{B} ===")
    print("Target vector:", t)

    # Simple rounding
    print("\nRunning simple rounding...")
    rounding_vec = simple_rounding(B, t)
    print("Closest lattice vector (rounding):", rounding_vec)

    # Simple enumeration
    print("\nRunning simple enumeration...")
    simple_enum_vec = simple_enumeration(B, t, l)
    print("Closest lattice vector (enumeration):", simple_enum_vec)

    # Fincke-Phost enumeration
    Bs = Gram_Schmidt_orth(B)
    x = nearest_plane(B, Bs, t)
    # r = 12
    r = np.linalg.norm(x - t)

    print("\nRunning Fincke-Phost enumeration...")
    fincke_pohst_enum_vec = fincke_pohst_enumeration(B, t, r)
    fincke_pohst_enum_vec_min = min(fincke_pohst_enum_vec, key=lambda v: np.linalg.norm(np.array(v) - t))
    print("Closest lattice vector (Fincke-Phost enumeration):", fincke_pohst_enum_vec_min)

    # Determine plotting bounds dynamically from all lattice coordinates
    all_x = np.concatenate([
        [0, t[0], rounding_vec[0], simple_enum_vec[0]] + [v[0] for v in fincke_pohst_enum_vec]
    ])
    all_y = np.concatenate([
        [0, t[1], rounding_vec[1], simple_enum_vec[1]] + [v[1] for v in fincke_pohst_enum_vec]
    ])

    margin = 5
    x_min = np.min(all_x) - margin
    x_max = np.max(all_x) + margin
    y_min = np.min(all_y) - margin
    y_max = np.max(all_y) + margin

    # Generate lattice in computed bounds
    xlim = (x_min, x_max)
    ylim = (y_min, y_max)
    lattice_vecs = generate_lattice_points(B, xlim, ylim)

    # Plot 1
    plt.clf()
    plt.scatter(lattice_vecs[:, 0], lattice_vecs[:, 1], c="black", label="Lattice Points")
    plt.scatter(t[0], t[1], c="red", marker="x", s=50, label="Target")
    plt.scatter(rounding_vec[0], rounding_vec[1], c="orange", label="Simple Rounding Result")
    plt.scatter(simple_enum_vec[0], simple_enum_vec[1], c="green", label="Simple Enumeration Result")
    draw_basis_vectors(B)
    draw_fundamental_regions(B, xlim, ylim)
    plt.xlim(x_min, x_max)
    plt.ylim(y_min, y_max)
    plt.legend(loc='upper center', bbox_to_anchor=(0.5, -0.1), ncol=2)
    plt.title(f"Enumerated Region (Basis:\n{B})")
    plt.tight_layout()
    plt.show()

    sleep(1)
    

    # Plot 2
    plt.clf()
    plt.scatter(lattice_vecs[:, 0], lattice_vecs[:, 1], c="black", label="Lattice Points")
    plt.scatter(t[0], t[1], c="red", marker="x", s=50, label="Target")
    circle = patches.Circle((t[0], t[1]), r, fill=False, color="blue", linestyle="--", label=f"Radius {r:.2f}")
    plt.gca().add_patch(circle)
    #plt.gca().set_aspect('equal', adjustable='box')
    for i, fp in enumerate(fincke_pohst_enum_vec):
        if i == 0:
            plt.scatter(fp[0], fp[1], c="magenta", label="Fincke-Phost Enumeration Result")
        else:
            plt.scatter(fp[0], fp[1], c="magenta")
    #plt.scatter(fincke_pohst_enum_vec_min[0], fincke_pohst_enum_vec_min[1], c="cyan", label="Fincke-Phost Enumeration Result")
    draw_basis_vectors(B)
    draw_fundamental_regions(B, xlim, ylim)
    plt.xlim(x_min, x_max)
    plt.ylim(y_min, y_max)
    plt.legend(loc='upper center', bbox_to_anchor=(0.5, -0.1), ncol=2)
    plt.title(f"Enumerated Region (Basis:\n{B})")
    plt.tight_layout()
    plt.show()

############
# Main runner
############
if __name__ == "__main__":

    # Diameter
    l = 4

    # Example bases
    bases = [
        np.array([[4, 0], [1, 4]], dtype=int),     # Pretty orthogonal basis
        np.array([[4, 4], [5, 8]], dtype=int)      # Stretched along x-axis
    ]

    # Target vector
    t = np.array([3.3, 8.4], dtype=float)

    # Run the demo for each basis
    for B in bases:
        run_lattice_demo(B, t, l)

