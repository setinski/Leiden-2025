import numpy as np
from numpy import zeros, array
import matplotlib.pyplot as plt
from test_bases import B2, B4, B24

# The exercises comprises of function to be implemented (except Exercise 0):
# Replace the keyword "pass" with your implementation of the desired function

############ 
# Exercise 0
# Warm-up: Lattices
############

def in_lattice(B, v):
	"""
    Check whether a vector `v` belongs to the lattice generated by the basis `B`,
	up to a small numerical tolerance.

    :param B: A square (n x n) NumPy array representing a lattice basis.
    :type B: numpy.ndarray
    :param v: A NumPy array representing the target vector to test.
    :type v: numpy.ndarray

    :return: True if `v` lies in the lattice generated by `B` (within numerical tolerance), False otherwise.
    :rtype: bool

    :notes: Make use of numpy.linalg function solve and numpy functions round and allclose.
	1. Write v in base B as x: x = B^T * v .
	2. Round to make it an integer vector. If v this indeed a lattice point,
	this step should merely fix floating-point numerical errors.
    3. Check equality up to some small tolerance.
    """
	x = np.linalg.solve(B.transpose(),v)
	xr = np.round(x)
	return np.allclose(x, xr)

############
# Exercise 1
# Implement the Simple Rounding Algorithm 
############

def simple_rounding(B, t):
	"""
    Return a lattice vector close to the target vector `t`, using the Simple Rounding algorithm.

    :param B: A square (n x n) NumPy array representing a lattice basis.
    :type B: numpy.ndarray
    :param t: A NumPy array representing the target vector to approximate with a lattice point.
    :type t: numpy.ndarray

    :return: A lattice vector in the lattice generated by `B` that is close to `t`.
    :rtype: numpy.ndarray

    :notes: Make use of numpy.linalg function solve and numpy function round.
    """
	

	pass


############
# Exercise 2
# Implement Gram-Schmidt Orthogonalization Algorihm
# Use a projection Subroutine
############

def orth_proj(x, y):
	"""
    Return the orthogonal projection of vector `x` orthogonally to vector `y`.

    This computes the component of `x` that is orthogonal to `y`, using the formula:
    x - (<x, y> / <y, y>) * y, where <·,·> denotes the dot product.

    :param x: A NumPy array representing the vector to be projected.
    :type x: numpy.ndarray
    :param y: A NumPy array representing the direction vector.
    :type y: numpy.ndarray

    :return: The projection of `x` orthogonally to `y`.
    :rtype: numpy.ndarray

    :notes: Make use of the dot product via `@` operator. Assumes `y` is non-zero.
    """
	
	pass

def Gram_Schmidt_orth(B):
	"""
    Perform Gram-Schmidt orthogonalization on the rows of a matrix `B`.

    :param B: A square (n x n) NumPy array representing the basis vectors of a lattice.
              Each row of `B` is considered a basis vector.
    :type B: numpy.ndarray

    :return: A NumPy array of the same shape as `B`, containing the orthogonalized basis vectors.
             The i-th row of the output is the orthogonal to the span of previous basis vectors.
    :rtype: numpy.ndarray

    :notes: Verify the following properties:
	1. The first Gram-Schmidt orthogonalization vector is the first basis vector.
	2. Span of the first i rows of the Gram-Schmidt orthogonalized basis is the same as the span
	of the first i rows of the lattice basis B.
	3. All Gram-Schmidt orthogonalized vectors are pairwise orthogonal.
	4. Each Gram-Schmidt orthogonalized vector is orthogonal to all the previous basis vectors.        
    """
	n = B.shape[0]
	for i in range(2,n):
		S = np.zeros(n)
		for j in range(1,i):
			m = (B[i] @ B[j])/(B[j] @ B[j])
			S = S + m*B[j]
		B[i] = B[i] - S
	return B


############
# Exercise 3
# Implement The Nearest-Plane Rounding Algorithm (Babai)
############

def nearest_plane(B, Bs, t):
	"""
    Apply Babai's Nearest Plane Algorithm to approximate a target vector `t`
    with a nearby lattice point from the lattice generated by basis `B`.

    :param B: A NumPy array of shape (n, d) representing the lattice basis.
              Each row of `B` is a basis vector.
    :type B: numpy.ndarray
    :param Bs: A NumPy array of shape (n, d) containing the Gram-Schmidt orthogonalization
               of the basis `B`.
    :type Bs: numpy.ndarray
    :param t: A NumPy array of shape (d,) representing the target vector to approximate.
    :type t: numpy.ndarray

    :return: A lattice vector (as a NumPy array) in the lattice generated by `B`,
             which is close to the target `t`.
    :rtype: numpy.ndarray

    :notes: Make use of numpy round() function and the built-in int() conversion.
	(!) Copy t, to avoid modying the value of the function caller.
    """

	pass

############
# Exercise 4
# Compare the distribution of Euclidean norm of points in the fundamental
# domains P(B) and P(Bs) given a basis B, by plotting their histograms.
# The plotting function is provided.
#
# There is no need to actually run simple_rounding nor nearest_plane.
############

def compare_norm_distrib(B, num_samples):
	"""
    Compare the distribution of vector norms in the fundamental domains of a basis `B`
    and its Gram-Schmidt orthogonalization `Bs`, by generating and plotting histograms.

    :param B: A NumPy array of shape (n, n) representing a lattice basis.
              Each row is treated as a basis vector.
    :type B: numpy.ndarray
    :param num_samples: The number of random samples to generate from each distribution.
    :type num_samples: int

    :notes: Make use of numpy.linalg function norm and numpy.random function rand, as well
	as 
    """

	pass
	

############
# Helper functions
############

def plot_two_hist(data_SR, data_NP, n, save=False):
	"""Take is input two lists and plot two histograms"""
	
	_, bins, _ = plt.hist(data_SR, bins=100, density=True, label="Simple Rounding")
	_ = plt.hist(data_NP, bins=bins, alpha=0.5, density=True, label="Nearest Plane")
	
	plt.title("Length of random points in Fundamental Parallelepiped \n Basis dimension: %d"%n)
	plt.legend()
	
	if save:
		plt.savefig("ParallelepipedDistDim%d.png"%n)
	else:
		plt.show()
	
	plt.clf()
	plt.close()
	

############
# Main runner
############
if __name__ == "__main__":
    plot_bases = [B2, B4, B24]

for B in plot_bases:
	print("\n========================================")
	print("Running in_lattice for basis with shape:", B.shape)
	print("For first basis vector:", in_lattice(B,B[0]))
	v = np.random.uniform(-100,100,B.shape)
	print("For a random vector", in_lattice(B, v))
input("Press Enter to continue...")
for B in plot_bases:
	print("\n========================================")
	print("Running compare_norm_distrib for basis with shape:", B.shape)
	compare_norm_distrib(B, 50000)
input("Press Enter to continue...")
for B in plot_bases:
	print("\n========================================")
	print("Testing Gram_Schmidt_orth for basis with shape:", B.shape )
	A = Gram_Schmidt_orth(B)
	print("1.Comparing first vectors")
	if A[0].all == B[0].all:
		print("Correct")
	else:
		print("Incorrect")

"""
1. The first Gram-Schmidt orthogonalization vector is the first basis vector.
2. Span of the first i rows of the Gram-Schmidt orthogonalized basis is the same as the span
of the first i rows of the lattice basis B.
3. All Gram-Schmidt orthogonalized vectors are pairwise orthogonal.
4. Each Gram-Schmidt orthogonalized vector is orthogonal to all the previous basis vectors
"""
