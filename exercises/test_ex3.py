import numpy as np
from numpy import array
import pytest

from ex3 import enumeration, simple_enumeration, fincke_pohst_enumeration
from ex2 import simple_rounding
from generic_functions import in_lattice

np.random.seed(42)

# -------------------- Test Data --------------------------
# Generate random bases, targets, and diameters for testing
dimensions = [1, 2, 4]

instances_per_dim = 5  # number of instances per dimension

bases = []
targets = []
diameters = []
radii = []

for dim in dimensions:
    for _ in range(instances_per_dim):
        B = np.random.randint(-30, 30, size=(dim, dim))
        
        # Check if full rank
        if np.linalg.matrix_rank(B) == dim:
            bases.append(B)
            # bases.append(np.random.randint(-30, 30, size=(dim, dim)))
            targets.append(np.random.uniform(-30, 30, size=(dim,)))
            diameters.append(np.random.randint(1, 5))

t_d = list(zip(targets, diameters))
B_t = list(zip(bases, targets))
B_t_l = list(zip(bases, targets, diameters))

# -------------------- Exercise 1 -------------------------

@pytest.mark.parametrize("t,d", t_d)
def test_enumerate(t, d):
    """Check that enumerate() returns unique integer vectors within coordinate-wise distance constraint."""
    
    r = d / 2
    results = enumeration(t, r)

    # Ensure results is iterable
    assert results is not None, "The function returned None."
    results_list = list(results)

    # Convert each vector to tuple of ints for uniqueness checks
    try:
        tuple_results = [tuple(map(int, np.round(z))) for z in results_list]
    except Exception as exc:
        pytest.fail(f"Failed converting results to integer tuples: {exc}")

    # Check if all solutions are distinct
    assert len(tuple_results) == len(set(tuple_results)), "Duplicate lattice vectors found."

    # Compute the expected number of results
    per_dim_counts = [
        int(np.ceil(t[i] + r) - np.ceil(t[i] - r))
        for i in range(len(t))
    ]
    expected_count = np.prod(per_dim_counts)

    assert len(tuple_results) == expected_count, (
        f"Expected {expected_count} results, got {len(tuple_results)}"
    )
    
    for y in results_list:
        # Check that all results are in the integer lattice
        assert in_lattice(np.eye(len(t)), y), f"{y} is not in the integer lattice."

        # Check coordinate-wise distance constraint
        assert np.all(np.abs(y - t) <= r + 1e-9), (
            f"{y} is not within coordinate-wise distance {r} from {t}"
        )
        
# -------------------- Exercise 2 -------------------------

@pytest.mark.parametrize("B,t,l", B_t_l)
def test_simple_enumeration_close_to_target(B, t, l):
    """Check enumerated vectors are in the lattice, within the correct fundamental domain,
    and that enumeration does not find a worse vector than simple rounding.
    """

    # Compute simple_rounding result
    try:
        x = simple_rounding(B, t)
    except Exception as exc:
        pytest.fail(f"simple_rounding(B, t) raised an exception: {exc}")
    dist_x = np.linalg.norm(x - t)

    # Check that x is in the lattice
    assert in_lattice(B, x), f"Result {x} is not in the lattice generated by B"

    # Check that x is in t + P(B)
    x_reduced = np.linalg.solve(B.transpose(), x - t)
    assert np.all(np.abs(x_reduced) <= 0.5 + 1e-9), (
        f"{x} is not in the fundamental domain around t. "
        f"Reduced coords: {x_reduced}"
    )

    # Compute enumeration results
    try:
        y = simple_enumeration(B, t, l)
    except Exception as exc:
        pytest.fail(f"simple_enumeration(B, t, l) raised an exception: {exc}")

    # Check that y is in the lattice
    assert in_lattice(B, y), f"Vector {y} is not in the lattice generated by B"

    # Check that y is in t + l * P(B)
    y_reduced = np.linalg.solve(B.transpose(), y - t)
    assert np.all(np.abs(y_reduced) <= l / 2 + 1e-9), (
        f"{y} is not in the scaled fundamental domain around t. "
        f"Reduced coords: {y_reduced}"
    )

    # Check y is not further from t than simple_rounding result
    dist_y = np.linalg.norm(y - t)
    assert dist_y <= dist_x + 1e-12, (
        f"Enumerated vector {y} (dist={dist_y:.6g}) is further from target "
        f"than simple_rounding result (dist={dist_x:.6g})"
    )


# -------------------- Exercise 4 -------------------------

@pytest.mark.parametrize("B,t", B_t)
def test_fp_enumeration_close_to_target(B, t):
    """Check enumerated vectors are in the lattice, within the correct ball,
    and that enumeration does not find a worse vector than simple rounding.
    """

    # Compute simple_rounding result
    try:
        x = simple_rounding(B, t)
    except Exception as exc:
        pytest.fail(f"simple_rounding(B, t) raised an exception: {exc}")
    dist_x = np.linalg.norm(x - t)

    # Check that x is in the lattice
    assert in_lattice(B, x), f"Result {x} is not in the lattice generated by B"

    # Check that x is in t + P(B)
    x_reduced = np.linalg.solve(B.transpose(), x - t)
    assert np.all(np.abs(x_reduced) <= 0.5 + 1e-9), (
        f"{x} is not in the fundamental domain around t. "
        f"Reduced coords: {x_reduced}"
    )

    # Compute enumeration results
    r = np.linalg.norm(x - t) + 0.5
    print(f"Using radius r = {r:.6g} for target {t} and basis\n{B}")
    try:
        y = min(fincke_pohst_enumeration(B, t, r), key=lambda v: np.linalg.norm(np.array(v) - t))
    except Exception as exc:
        pytest.fail(f"fincke_pohst_enumeration(B, t, r) raised an exception: {exc}")

    # Check that y is in the lattice
    assert in_lattice(B, y), f"Vector {y} is not in the lattice generated by B"

    # Check that y is in t + B(r)
    y_reduced = np.linalg.solve(B.transpose(), y - t)
    assert np.linalg.norm(y_reduced) <= r / 2 + 1e-9, (
        f"{y} is not in the scaled fundamental domain around t. "
        f"Reduced coords: {y_reduced}"
    )

    # # Check y is not further from t than simple_rounding result
    # dist_y = np.linalg.norm(y - t)
    # assert dist_y <= dist_x + 1e-12, (
    #     f"Enumerated vector {y} (dist={dist_y:.6g}) is further from target "
    #     f"than simple_rounding result (dist={dist_x:.6g})"
    # )
