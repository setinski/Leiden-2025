import numpy as np
from numpy import zeros, array
import matplotlib.pyplot as plt
from generic_functions import generate_lattice_points, draw_basis_vectors, draw_fundamental_regions
from test_bases import B2, B4, B24

save_counter = 0

save_counter = 0

# The exercises comprises of function to be implemented:
# Replace the keyword "pass" with your implementation of the desired function

############ 
# Exercise 0
# Warm-up: Lattices
############

def in_lattice(B, v):
	"""
    Check whether a vector `v` belongs to the lattice generated by the basis `B`,
	up to a small numerical tolerance.

    :param B: A square (n x n) NumPy array representing a lattice basis.
    :type B: numpy.ndarray
    :param v: A NumPy array representing the target vector to test.
    :type v: numpy.ndarray

    :return: True if `v` lies in the lattice generated by `B` (within numerical tolerance), False otherwise.
    :rtype: bool

    :notes: Make use of numpy.linalg function solve and numpy functions round and allclose.
    """

	pass


############
# Exercise 1
# Implement the Simple Rounding Algorithm 
############

def simple_rounding(B, t):
    """
    Return a lattice vector close to the target vector `t`, using the Simple Rounding algorithm.

    :param B: A square (n x n) NumPy array representing a lattice basis.
    :type B: numpy.ndarray
    :param t: A NumPy array representing the target vector to approximate with a lattice point.
    :type t: numpy.ndarray

    :return: A lattice vector in the lattice generated by `B` that is close to `t`.
    :rtype: numpy.ndarray

    :notes: Make use of numpy.linalg function solve and numpy function round.
    """
    
    pass


############
# Exercise 2
# Implement Gram-Schmidt Orthogonalization Algorihm
# Use a projection Subroutine
############

def orth_proj(x, y):
    """
    Return the projection of vector `x` orthogonally to vector `y`, using the formula:
    (<x, y> / <y, y>) * y, where <·,·> denotes the inner product.

    :param x: A NumPy array representing the vector to be projected.
    :type x: numpy.ndarray
    :param y: A NumPy array representing the direction vector.
    :type y: numpy.ndarray

    :return: The projection of `x` orthogonally to `y`.
    :rtype: numpy.ndarray
    """
	
    if np.allclose(y, 0):
        return 0
	
    pass


def Gram_Schmidt_orth(B):
	"""
    Perform Gram-Schmidt orthogonalization on the rows of a matrix `B`.

    :param B: A square (n x n) NumPy array representing the basis vectors of a lattice.
              Each row of `B` is considered a basis vector.
    :type B: numpy.ndarray

    :return: A NumPy array of the same shape as `B`, containing the orthogonalized basis vectors.
             The i-th row of the output is the orthogonal to the span of previous basis vectors.
    :rtype: numpy.ndarray   
    """

	pass


############
# Exercise 3
# Implement The Nearest-Plane Rounding Algorithm (Babai)
############

def nearest_plane(B, Bs, t):
	"""
    Apply Babai's Nearest Plane Algorithm to approximate a target vector `t`
    with a nearby lattice point from the lattice generated by basis `B`.

    :param B: A NumPy array of shape (n, d) representing the lattice basis.
              Each row of `B` is a basis vector.
    :type B: numpy.ndarray
    :param Bs: A NumPy array of shape (n, d) containing the Gram-Schmidt orthogonalization
               of the basis `B`.
    :type Bs: numpy.ndarray
    :param t: A NumPy array of shape (d,) representing the target vector to approximate.
    :type t: numpy.ndarray

    :return: A lattice vector (as a NumPy array) in the lattice generated by `B`,
             which is close to the target `t`.
    :rtype: numpy.ndarray

    :notes: Make use of numpy round() function and the built-in int() conversion.
    (!) Use built-in copy function to create a copy of t.
    """

	pass

############
# Exercise 4
# Compare the distribution of Euclidean norm of points in the fundamental
# domains P(B) and P(Bs) given a basis B, by plotting their histograms.
# The plotting function is provided.
#
# There is no need to actually run simple_rounding nor nearest_plane.
############

def compare_norm_distrib(B, num_samples):
	"""
    Compare the distribution of vector norms in the fundamental parallelepiped
    of a lattice basis `B` versus its Gram–Schmidt orthogonalization `Bs`.
    B : numpy.ndarray of shape (n, n)
        Lattice basis matrix. Each row is treated as a basis vector.
    num_samples : int
        Number of random samples to draw from each distribution.

    Notes
    -----
    - Uses `numpy.random.rand` to generate random coefficients in [0, 1),
      which are shifted to [-0.5, 0.5] to center the sampling domain.
    - Uses `numpy.linalg.norm` to compute Euclidean lengths.
    - Visualization is handled by `plot_two_hist` provided below.
    """

	pass
	

############
# Helper functions
############

def plot_two_hist(data_SR, data_NP, n, save=True):
    """Take is input two lists and plot two histograms"""
def plot_two_hist(data_SR, data_NP, n, save=True):
    """Take is input two lists and plot two histograms"""
	
    _, bins, _ = plt.hist(data_SR, bins=100, density=True, label="Simple Rounding")
    _ = plt.hist(data_NP, bins=bins, alpha=0.5, density=True, label="Nearest Plane")
    _, bins, _ = plt.hist(data_SR, bins=100, density=True, label="Simple Rounding")
    _ = plt.hist(data_NP, bins=bins, alpha=0.5, density=True, label="Nearest Plane")
	
    plt.title("Length of random points in Fundamental Parallelepiped \n Basis dimension: %d"%n)
    plt.legend()
    plt.title("Length of random points in Fundamental Parallelepiped \n Basis dimension: %d"%n)
    plt.legend()
	
    if save:
        plt.savefig("ParallelepipedDistDim%d.png"%n)
    else:
        plt.show()
    if save:
        plt.savefig("ParallelepipedDistDim%d.png"%n)
    else:
        plt.show()
	
    plt.clf()
    plt.close()
    plt.clf()
    plt.close()
	

def plot_lattice_scene(B, xlim, ylim, t=None, rounding_vec=None, show_gs=False, title="", save=True):
def plot_lattice_scene(B, xlim, ylim, t=None, rounding_vec=None, show_gs=False, title="", save=True):
    """Draw lattice tiling, points, basis, and optional extras."""
    plt.figure(figsize=(6, 6))

    # Draw background tiling
    draw_fundamental_regions(B, xlim, ylim)

    # Draw lattice points
    pts = generate_lattice_points(B, xlim, ylim)
    plt.scatter(pts[:, 0], pts[:, 1], s=20, c="black", zorder=2, label="Lattice points")

    # Draw basis vectors (blue)
    draw_basis_vectors(B)

    # Optionally overlay Gram–Schmidt orthogonalized basis
    if show_gs:
        Bs = Gram_Schmidt_orth(B)
        for i in range(2):
            plt.arrow(0, 0, Bs[i, 0], Bs[i, 1],
                      head_width=0.3, head_length=0.3,
                      fc="red", ec="red", length_includes_head=True)

    # Plot target vector if provided
    if not show_gs:
        plt.scatter(t[0], t[1], c="red", s=30, marker="o", zorder=3, label="Target vector")

    # Plot rounding result if provided
    if rounding_vec is not None:
        plt.scatter(rounding_vec[0], rounding_vec[1], c="orange", s=80, marker="x", zorder=3, label="Simple rounding")

    plt.xlim(xlim)
    plt.ylim(ylim)
    plt.gca().set_aspect("equal", adjustable="box")
    plt.title(title)
    plt.legend()

    if save:
        global save_counter
        filename = f"Lattice_{B.shape[0]}_{save_counter}.png"
        plt.savefig(filename)
        save_counter += 1
    else:
        plt.show()

    if save:
        global save_counter
        filename = f"Lattice_{B.shape[0]}_{save_counter}.png"
        plt.savefig(filename)
        save_counter += 1
    else:
        plt.show()

    plt.clf()
    plt.close()

    plt.clf()
    plt.close()


############
# Main runner
############
if __name__ == "__main__":
    # Example bases
    bases = [
        np.array([[4, 0], [1, 4]], dtype=int),
        np.array([[4, 4], [5, 8]], dtype=int)
    ]

    # Example target vector
    t = np.array([3.3, 8.4], dtype=float)

    # Plot limits
    xlim, ylim = (-13, 13), (-13, 13)

    ##### 1. Simple rounding #####
    for B in bases:
        print("\n=== Simple Rounding ===")
        print("Basis:\n", B)
        rounding_vec = simple_rounding(B, t)
        print("Rounding result:", rounding_vec)

        plot_lattice_scene(B, xlim, ylim, t=t, rounding_vec=rounding_vec,
                           title="2D lattice with Simple Rounding")

    input("Press Enter to continue...")

    ##### 2. Gram-Schmidt #####
    for B in bases:
        print("\n=== Gram-Schmidt ===")
        print("Basis:\n", B)

        plot_lattice_scene(B, xlim, ylim, t=t, show_gs=True,
                           title="2D lattice with Gram-Schmidt basis")

    input("Press Enter to continue...")

    ##### 3. Nearest-plane (norm distribution) #####
    designed_bases = [B2, B4, B24]
    for B in designed_bases:
        print("\n=== Nearest-Plane (Norm Distribution) ===")
        print("Running compare_norm_distrib for basis with shape:", B.shape)
        compare_norm_distrib(B, 50000)
