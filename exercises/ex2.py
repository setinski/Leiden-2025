import numpy as np
from numpy import zeros, array
import matplotlib.pyplot as plt
from test_bases import B2, B4, B24


# The exercises comprises of function to be implemented (except Exercise 0):
# Replace the keyword "pass" with your implementation of the desired function

############ 
# Exercise 0
# Warm-up: Lattices
############

def in_lattice(B, v):
    """
    Check whether a vector `v` belongs to the lattice generated by the basis `B`,
    up to a small numerical tolerance.

    :param B: A square (n x n) NumPy array representing a lattice basis.
    :type B: numpy.ndarray
    :param v: A NumPy array representing the target vector to test.
    :type v: numpy.ndarray

    :return: True if `v` lies in the lattice generated by `B` (within numerical tolerance), False otherwise.
    :rtype: bool

    :notes: Make use of numpy.linalg function solve and numpy functions round and allclose.
    1. Write v in base B as x: x = B^T * v .
    2. Round to make it an integer vector. If v this indeed a lattice point,
    this step should merely fix floating-point numerical errors.
    3. Check equality up to some small tolerance.
    """

    BT = np.transpose(B)
    x = np.linalg.solve(BT, v)
    xr = np.round(x)
    if np.allclose(xr, x):
        return True
    else: return False

"""
B = np.array([[-30,32],[36,24]])
v = np.array([-462, 56])
print(in_lattice(B,v))

B = np.array([[2,0],[3,3]])
v = np.array([1,3])
print(in_lattice(B,v))
"""

############
# Exercise 1
# Implement the Simple Rounding Algorithm
############

def simple_rounding(B, t):
    """
    Return a lattice vector close to the target vector `t`, using the Simple Rounding algorithm.

    :param B: A square (n x n) NumPy array representing a lattice basis.
    :type B: numpy.ndarray
    :param t: A NumPy array representing the target vector to approximate with a lattice point.
    :type t: numpy.ndarray

    :return: A lattice vector in the lattice generated by `B` that is close to `t`.
    :rtype: numpy.ndarray

    :notes: Make use of numpy.linalg function solve and numpy function round.
    """
    BT = np.transpose(B)
    tprime = np.linalg.inv(BT) @ t
    vprime = np.round(tprime)
    v = BT @ vprime
    return v

"""
B = np.array([[2,0],[3,3]])
v = np.array([1.1,1])	
print(simple_rounding(B,v))
"""


############
# Exercise 2
# Implement Gram-Schmidt Orthogonalization Algorihm
# Use a projection Subroutine
############

def orth_proj(x, y):
    """
    Return the orthogonal projection of vector `x` orthogonally to vector `y`.

    This computes the component of `x` that is orthogonal to `y`, using the formula:
    x - (<x, y> / <y, y>) * y, where <·,·> denotes the dot product.

    :param x: A NumPy array representing the vector to be projected.
    :type x: numpy.ndarray
    :param y: A NumPy array representing the direction vector.
    :type y: numpy.ndarray

    :return: The projection of `x` orthogonally to `y`.
    :rtype: numpy.ndarray

    :notes: Make use of the dot product via `@` operator. Assumes `y` is non-zero.
    """

    return (x @ y) / (y @ y) * y


"""
x = np.array([1,1,1])
y = np.array([0,1,0])
print(orth_proj(x,y))
"""


def Gram_Schmidt_orth(B):
    """
    Perform Gram-Schmidt orthogonalization on the rows of a matrix `B`.

    :param B: A square (n x n) NumPy array representing the basis vectors of a lattice.
              Each row of `B` is considered a basis vector.
    :type B: numpy.ndarray

    :return: A NumPy array of the same shape as `B`, containing the orthogonalized basis vectors.
             The i-th row of the output is the orthogonal to the span of previous basis vectors.
    :rtype: numpy.ndarray

    :notes: Verify the following properties:
    1. The first Gram-Schmidt orthogonalization vector is the first basis vector.
    2. Span of the first i rows of the Gram-Schmidt orthogonalized basis is the same as the span
    of the first i rows of the lattice basis B.
    3. All Gram-Schmidt orthogonalized vectors are pairwise orthogonal.
    4. Each Gram-Schmidt orthogonalized vector is orthogonal to all the previous basis vectors.
    """
    #didnt use previous function
    A = np.zeros(B.shape, dtype=float)
    n = B.shape[0]
    for i in range(n):
        A[i,:] = B[i,:]
        for j in range(i):
            A[i,:] -= orth_proj(B[i,:], A[j,:])
    if np.allclose(A[0,:],B[0,:]):
        print("First vectors coincide.")
    else: print("First vectors do not coincide.")
    m = 5
    for i in range(n):
        q = np.ones((2*(i+1),n))
        ac = np.ones((i+1,n))
        bc = np.ones((i+1,n))
        for j in range(i+1):
            q[j,:] = B[j,:]
            q[i+j+1,:] = A[j,:]
            ac[j,:] = A[j,:]
            bc[j,:] = B[j,:]
        if (np.linalg.matrix_rank(q) != np.linalg.matrix_rank(ac)
                or np.linalg.matrix_rank(bc) != np.linalg.matrix_rank(q)):
            if m== 5:
                print("The spans of the two bases do not coincide.")
                m=4
    if m==5:
        print("The spans of the two bases coincide.")
    m = 5
    for i in range(n):
        for j in range(n):
            if i != j and A[i,:]@A[j,:] != 0 and m == 5:
                print("The vectors in the GSO are not orthogonal.")
                m = 4
    if m == 5:
        print("The vectors in the GSO are orthogonal.")
    m = 5
    for i in range(n):
        for j in range(i):
            if A[i,:]@B[j,:] != 0 and m == 5:
                print("The vectors in the GSO are not orthogonal to the previous vectors in original basis.")
                m = 4
    if m == 5:
        print("The vectors in the GSO are orthogonal to the previous vectors in original basis.")
    return A

############
# Exercise 3
# Implement The Nearest-Plane Rounding Algorithm (Babai)
############

def nearest_plane(B, Bs, t):
    """
    Apply Babai's Nearest Plane Algorithm to approximate a target vector `t`
    with a nearby lattice point from the lattice generated by basis `B`.

    :param B: A NumPy array of shape (n, d) representing the lattice basis.
              Each row of `B` is a basis vector.
    :type B: numpy.ndarray
    :param Bs: A NumPy array of shape (n, d) containing the Gram-Schmidt orthogonalization
               of the basis `B`.
    :type Bs: numpy.ndarray
    :param t: A NumPy array of shape (d,) representing the target vector to approximate.
    :type t: numpy.ndarray

    :return: A lattice vector (as a NumPy array) in the lattice generated by `B`,
             which is close to the target `t`.
    :rtype: numpy.ndarray

    :notes: Make use of numpy round() function and the built-in int() conversion.
    (!) Copy t, to avoid modying the value of the function caller.
    """
    #BT = np.transpose(B)
    #BsT = np.transpose(Bs)
    n = B.shape[0]
    v = np.zeros((1,n))
    e = np.copy(t)
    for j in range(n):
        i = n-j-1
        k1 = e@Bs[i]
        k2 = Bs[i]@Bs[i]
        k = k1/k2
        k = np.round(k)
        k = int(k)
        v = v + k*B[i]
        e = e - k*B[i]
    return v.reshape((n,))

"""
B = np.array([[2,0],[3,3]])
Bs = Gram_Schmidt_orth(B)
t = np.array([1000,1001])
print(nearest_plane(B,Bs,t))
#x = np.transpose(nearest_plane(B,Bs,t))
x= nearest_plane(B,Bs,t)
print(in_lattice(B,x))
"""

############
# Exercise 4
# Compare the distribution of Euclidean norm of points in the fundamental
# domains P(B) and P(Bs) given a basis B, by plotting their histograms.
# The plotting function is provided.
#
# There is no need to actually run simple_rounding nor nearest_plane.
############

############
# Helper functions
############

def plot_two_hist(data_SR, data_NP, n, save=False):
    """Take is input two lists and plot two histograms"""

    _, bins, _ = plt.hist(data_SR, bins=100, density=True, label="Simple Rounding")
    _ = plt.hist(data_NP, bins=bins, alpha=0.5, density=True, label="Nearest Plane")

    plt.title("Length of random points in Fundamental Parallelepiped \n Basis dimension: %d" % n)
    plt.legend()

    if save:
        plt.savefig("ParallelepipedDistDim%d.png" % n)
    else:
        plt.show()

    plt.clf()
    plt.close()

def compare_norm_distrib(B, num_samples):
    """
    Compare the distribution of vector norms in the fundamental domains of a basis `B`
    and its Gram-Schmidt orthogonalization `Bs`, by generating and plotting histograms.

    :param B: A NumPy array of shape (n, n) representing a lattice basis.
              Each row is treated as a basis vector.
    :type B: numpy.ndarray
    :param num_samples: The number of random samples to generate from each distribution.
    :type num_samples: int

    :notes: Make use of numpy.linalg function norm and numpy.random function rand, as well
    as
    """

    vB  =np.ones(num_samples)
    vBs = np.ones(num_samples)
    n = B.shape[0]
    Bs = Gram_Schmidt_orth(B)
    k = np.random.randint(low=0, high=n-1, size=num_samples) #maybe problem that now
    #multiple entries of k may contain same value
    for i in range(num_samples):
        vB[i] = np.linalg.norm(B[k[i], :])
        vBs[i] = np.linalg.norm(Bs[k[i], :])
    m = np.max(vBs)+10
    if np.max(vB) > np.max(vBs):
        m = np.max(vB)+10
    _, bins, _ = plt.hist(vB, bins=100, density=True, label="basis")
    _ = plt.hist(vBs, bins=bins, alpha=0.5, density=True, label="basis GSO")
    plt.legend()
    plt.show()

"""
B = np.array([[2,0],[3,3]])
p = 2
compare_norm_distrib(B,p)
"""

############
# Helper functions
############

def plot_two_hist(data_SR, data_NP, n, save=False):
    """Take is input two lists and plot two histograms"""

    _, bins, _ = plt.hist(data_SR, bins=100, density=True, label="Simple Rounding")
    _ = plt.hist(data_NP, bins=bins, alpha=0.5, density=True, label="Nearest Plane")

    plt.title("Length of random points in Fundamental Parallelepiped \n Basis dimension: %d" % n)
    plt.legend()

    if save:
        plt.savefig("ParallelepipedDistDim%d.png" % n)
    else:
        plt.show()

    plt.clf()
    plt.close()


############
# Main runner
############
if __name__ == "__main__":
    plot_bases = [B2, B4, B24]

    for B in plot_bases:
        print("\n========================================")
        print("Running compare_norm_distrib for basis with shape:", B.shape)
        compare_norm_distrib(B, 50000)
