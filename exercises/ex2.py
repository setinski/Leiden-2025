import numpy as np
from numpy import zeros, array
import matplotlib.pyplot as plt
from generic_functions import generate_lattice_points, draw_basis_vectors, draw_fundamental_regions
from test_bases import B2, B4, B24

save_counter = 0

# The exercises comprises of function to be implemented:
# Replace the keyword "pass" with your implementation of the desired function

############ 
# Exercise 0
# Warm-up: Lattices
############

def in_lattice(B, v):
	"""
	Check whether a vector `v` belongs to the lattice generated by the basis `B`,
	up to a small numerical tolerance.

	:param B: A square (n x n) NumPy array representing a lattice basis.
	:type B: numpy.ndarray
	:param v: A NumPy array representing the target vector to test.
	:type v: numpy.ndarray

	:return: True if `v` lies in the lattice generated by `B` (within numerical tolerance), False otherwise.
	:rtype: bool

	:notes: Make use of numpy.linalg function solve and numpy functions round and allclose.
	"""
	x = np.linalg.solve(B.transpose(),v)
	xr = np.round(x)
	return np.allclose(x, xr)


############
# Exercise 1
# Implement the Simple Rounding Algorithm 
############

def simple_rounding(B, t):
	"""
	Return a lattice vector close to the target vector `t`, using the Simple Rounding algorithm.

	:param B: A square (n x n) NumPy array representing a lattice basis.
	:type B: numpy.ndarray
	:param t: A NumPy array representing the target vector to approximate with a lattice point.
	:type t: numpy.ndarray

	:return: A lattice vector in the lattice generated by `B` that is close to `t`.
	:rtype: numpy.ndarray

	:notes: Make use of numpy.linalg function solve and numpy function round.
	"""

	x = np.linalg.solve(B.transpose(),t)
	xr = np.round(x)
	return xr @ B


############
# Exercise 2
# Implement Gram-Schmidt Orthogonalization Algorihm
# Use a projection Subroutine
############

def orth_proj(x, y):
	"""
	Return the projection of vector `x` orthogonally to vector `y`, using the formula:
	(<x, y> / <y, y>) * y, where <·,·> denotes the inner product.

	:param x: A NumPy array representing the vector to be projected.
	:type x: numpy.ndarray
	:param y: A NumPy array representing the direction vector.
	:type y: numpy.ndarray

	:return: The projection of `x` orthogonally to `y`.
	:rtype: numpy.ndarray
	"""
	if np.allclose(y, 0):
        	return 0
	return (x @ y)/(y @ y) * y


def Gram_Schmidt_orth(B):
	"""
    Perform Gram-Schmidt orthogonalization on the rows of a matrix `B`.

    :param B: A square (n x n) NumPy array representing the basis vectors of a lattice.
              Each row of `B` is considered a basis vector.
    :type B: numpy.ndarray

    :return: A NumPy array of the same shape as `B`, containing the orthogonalized basis vectors.
             The i-th row of the output is the orthogonal to the span of previous basis vectors.
    :rtype: numpy.ndarray   
    """
	n = B.shape[0]
	A = B.copy()
	A = A.astype(float)
	for i in range(1,n):
		for j in range(i):
			A[i] = A[i] - orth_proj(B[i], A[j])
	return A


############
# Exercise 3
# Implement The Nearest-Plane Rounding Algorithm (Babai)
############

def nearest_plane(B, Bs, t):
	"""
    Apply Babai's Nearest Plane Algorithm to approximate a target vector `t`
    with a nearby lattice point from the lattice generated by basis `B`.

    :param B: A NumPy array of shape (n, d) representing the lattice basis.
              Each row of `B` is a basis vector.
    :type B: numpy.ndarray
    :param Bs: A NumPy array of shape (n, d) containing the Gram-Schmidt orthogonalization
               of the basis `B`.
    :type Bs: numpy.ndarray
    :param t: A NumPy array of shape (d,) representing the target vector to approximate.
    :type t: numpy.ndarray

    :return: A lattice vector (as a NumPy array) in the lattice generated by `B`,
             which is close to the target `t`.
    :rtype: numpy.ndarray

    :notes: Make use of numpy round() function and the built-in int() conversion.
    """
	n = B.shape[0]
	v = np.zeros(n)
	e = t.copy()
	for i in range(n-1,-1,-1):
		k = int(np.round((e @ Bs[i])/(Bs[i] @ Bs[i])))
		v += k*B[i]
		e -= k*B[i]
	return v

############
# Exercise 4
# Compare the distribution of Euclidean norm of points in the fundamental
# domains P(B) and P(Bs) given a basis B, by plotting their histograms.
# The plotting function is provided.
#
# There is no need to actually run simple_rounding nor nearest_plane.
############

def compare_norm_distrib(B, num_samples):
	"""
    Compare the distribution of vector norms in the fundamental parallelepiped
    of a lattice basis `B` versus its Gram–Schmidt orthogonalization `Bs`.
    B : numpy.ndarray of shape (n, n)
        Lattice basis matrix. Each row is treated as a basis vector.
    num_samples : int
        Number of random samples to draw from each distribution.

    Notes
    -----
    - Uses `numpy.random.rand` to generate random coefficients in [0, 1),
      which are shifted to [-0.5, 0.5] to center the sampling domain.
    - Uses `numpy.linalg.norm` to compute Euclidean lengths.
    - Visualization is handled by `plot_two_hist` provided below.
    """
	n = B.shape[0]
	A = np.zeros((2,num_samples), dtype=float)
	Bs = Gram_Schmidt_orth(B)
	for i in range(num_samples):
		v = np.random.rand(n)
		v -= 0.5
		vb = B @ v
		vbs = Bs @ v
		A[0][i] = np.linalg.norm(vb)
		A[1][i] = np.linalg.norm(vbs)

	return A
	

############
# Helper functions
############

def plot_two_hist(data_SR, data_NP, n, save=True):
    """Take is input two lists and plot two histograms"""
	
    _, bins, _ = plt.hist(data_SR, bins=100, density=True, label="Original basis")
    _ = plt.hist(data_NP, bins=bins, alpha=0.5, density=True, label="Orthogonal basis")
	
    plt.title("Length of random points in Fundamental Parallelepiped \n Basis dimension: %d"%n)
    plt.legend()
	
    if save:
        plt.savefig("ParallelepipedDistDim%d.png"%n)
    else:
        plt.show()
	
    plt.clf()
    plt.close()
	

def plot_lattice_scene(B, xlim, ylim, t=None, rounding_vec=None, show_gs=False, title="", save=True):
    """Draw lattice tiling, points, basis, and optional extras."""
    plt.figure(figsize=(6, 6))

    # Draw background tiling
    draw_fundamental_regions(B, xlim, ylim)

    # Draw lattice points
    pts = generate_lattice_points(B, xlim, ylim)
    plt.scatter(pts[:, 0], pts[:, 1], s=20, c="black", zorder=2, label="Lattice points")

    # Draw basis vectors (blue)
    draw_basis_vectors(B)

    # Optionally overlay Gram–Schmidt orthogonalized basis
    if show_gs:
        Bs = Gram_Schmidt_orth(B)
        for i in range(2):
            plt.arrow(0, 0, Bs[i, 0], Bs[i, 1],
                      head_width=0.3, head_length=0.3,
                      fc="red", ec="red", length_includes_head=True)

    # Plot target vector if provided
    if not show_gs:
        plt.scatter(t[0], t[1], c="red", s=30, marker="o", zorder=3, label="Target vector")

    # Plot rounding result if provided
    if rounding_vec is not None:
        plt.scatter(rounding_vec[0], rounding_vec[1], c="orange", s=80, marker="x", zorder=3, label="Simple rounding")

    plt.xlim(xlim)
    plt.ylim(ylim)
    plt.gca().set_aspect("equal", adjustable="box")
    plt.title(title)
    plt.legend()

    if save:
        global save_counter
        filename = f"Lattice_{B.shape[0]}_{save_counter}.png"
        plt.savefig(filename)
        save_counter += 1
    else:
        plt.show()

    plt.clf()
    plt.close()


############
# Main runner
############
if __name__ == "__main__":
	plot_bases = [B2, B4, B24]

	for B in plot_bases:
		print("\n========================================")
		print("Running in_lattice for basis with shape:", B.shape)
		print("For first basis vector:", in_lattice(B,B[0]))
		v = np.random.uniform(-100,100,B.shape[0])
		print("For a random vector:", in_lattice(B, v))
	input("Press Enter to continue...")

	for B in plot_bases:
		print("\n========================================")
		print("Testing simple rounding for basis with shape:", B.shape)
		v = np.random.uniform(-100,100,B.shape[0])
		sr = simple_rounding(B,v)
		print("Is the result in the lattice?", in_lattice(B,sr))
		print("Is the result close to the target?")
		e = v - sr
		ep = np.linalg.solve(B.transpose(),e)
		if np.round(ep).all() == 0:
			print("Yes")
		else:
			print("No")
	input("Press Enter to continue...")

	for B in plot_bases:
		print("\n========================================")
		print("Testing Babai for basis with shape:", B.shape)
		t = np.random.uniform(-100,100,B.shape[0])
		v = nearest_plane(B, Gram_Schmidt_orth(B),t)
		print("Is babai output in lattice?", in_lattice(B,v))
	input("Press Enter to continue...")

	for B in plot_bases:
		print("\n========================================")
		print("Running compare_norm_distrib for basis with shape:", B.shape)
		A = compare_norm_distrib(B, 50000)
		#print("Norms of vectors in a fundamental domain of B and Bs:")
		#print(A)
		plot_two_hist(A[0],A[1],50000)
	input("Press Enter to continue...")

	for B in plot_bases:
		print("\n========================================")
		print("Testing Gram_Schmidt_orth for basis with shape:", B.shape )
		A = Gram_Schmidt_orth(B)
		print("1.Comparing first vectors")
		if A[0].all() == B[0].all():
			print("Correct")
		else:
			print("Incorrect")
		print("Comparing the spans of first i rows")
		check = True
		for i in range(0,B.shape[0]):
			C = np.concatenate((A[0:i+1][:],B[0:i+1][:]), axis = 0)
			if np.linalg.matrix_rank(A[0:i+1][:]) != np.linalg.matrix_rank(C) or np.linalg.matrix_rank(B[0:i+1][:]) != np.linalg.matrix_rank(C):
				check = False
		if check == True:
			print("All spans are the same")
		else:
			print("At least one span is wrong")
	input("Press Enter to continue...")

	"""
	1. The first Gram-Schmidt orthogonalization vector is the first basis vector.
	2. Span of the first i rows of the Gram-Schmidt orthogonalized basis is the same as the span
	of the first i rows of the lattice basis B.
	3. All Gram-Schmidt orthogonalized vectors are pairwise orthogonal.
	4. Each Gram-Schmidt orthogonalized vector is orthogonal to all the previous basis vectors
	"""

	# Example bases
	bases = [
	np.array([[4, 0], [1, 4]], dtype=int),
	np.array([[4, 4], [5, 8]], dtype=int)
	]

	# Example target vector
	t = np.array([3.3, 8.4], dtype=float)

	# Plot limits
	xlim, ylim = (-13, 13), (-13, 13)

	##### 1. Simple rounding #####
	for B in bases:
		print("\n=== Simple Rounding ===")
		print("Basis:\n", B)
		rounding_vec = simple_rounding(B, t)
		print("Rounding result:", rounding_vec)

		plot_lattice_scene(B, xlim, ylim, t=t, rounding_vec=rounding_vec,title="2D lattice with Simple Rounding")

	input("Press Enter to continue...")

	##### 2. Gram-Schmidt #####
	for B in bases:
		print("\n=== Gram-Schmidt ===")
		print("Basis:\n", B)

		plot_lattice_scene(B, xlim, ylim, t=t, show_gs=True, title="2D lattice with Gram-Schmidt basis")

	input("Press Enter to continue...")

	##### 3. Nearest-plane (norm distribution) #####
	designed_bases = [B2, B4, B24]
	for B in designed_bases:
		print("\n=== Nearest-Plane (Norm Distribution) ===")
		print("Running compare_norm_distrib for basis with shape:", B.shape)
		compare_norm_distrib(B, 50000)
