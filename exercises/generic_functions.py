import numpy as np
import matplotlib.pyplot as plt

def in_lattice(B, v, tol=1e-10):
    """
    Check whether a vector `v` belongs to the lattice generated by the basis `B`,
    up to a small numerical tolerance, using a least-squares approach.

    :param B: A square (n x n) NumPy array representing a lattice basis.
    :type B: numpy.ndarray
    :param v: A NumPy array representing the target vector to test.
    :type v: numpy.ndarray
    :param tol: Numerical tolerance for checking integer coefficients.
    :type tol: float

    :return: True if `v` lies in the lattice generated by `B` (within numerical tolerance), False otherwise.
    :rtype: bool
    """
    # Solve least squares: B.T @ coeffs ≈ v
    coeffs, _, _, _ = np.linalg.lstsq(B.T, v, rcond=None)
    
    # Round coefficients to nearest integers
    coeffs_rounded = np.round(coeffs)
    
    # Check if all coefficients are close to integers
    if np.allclose(coeffs, coeffs_rounded, atol=tol):
        return True
    else:
        return False

def in_span(A, v, tol=1e-10):
    """
    Check whether a row-vector v belongs to the span of the rows of A.
    
    A : (k, d) array, k row-vectors in R^d
    v : (d,) array
    """
    # Solve least squares: A.T @ c ≈ v
    coeffs, residuals, _, _ = np.linalg.lstsq(A.T, v, rcond=None)

    # If residuals are reported (overdetermined case)
    if residuals.size > 0:
        return residuals[0] < tol
    else:
        # Underdetermined but exact: check reconstruction
        return np.allclose(A.T @ coeffs, v, atol=tol)

def generate_lattice_points(B, xlim, ylim):
    """
    Generate all lattice points lying inside a given axis-aligned rectangular
    region in Euclidean space, for a 2D lattice defined by a basis matrix.

    Given a 2×2 lattice basis `B`, each lattice point can be expressed as
    B @ [i, j] where i and j are integers (lattice coordinates). The function
    returns all such points whose Euclidean coordinates (x, y) lie within
    the rectangle defined by `xlim` and `ylim`.

    :param B: A 2×2 NumPy array whose columns are the basis vectors of the lattice.
    :type B: numpy.ndarray
    :param xlim: Tuple (xmin, xmax) specifying the horizontal extent of the box
                in Euclidean coordinates.
    :type xlim: tuple of float
    :param ylim: Tuple (ymin, ymax) specifying the vertical extent of the box
                in Euclidean coordinates.
    :type ylim: tuple of float

    :return: A NumPy array of shape (m, 2), where each row is the (x, y) coordinate
            of a lattice point inside the specified box.
    :rtype: numpy.ndarray

    :notes: This function works by mapping the bounding box corners into lattice
            coordinate space using the inverse of `B`, determining the integer
            index range that covers the box, and then filtering only those lattice
            points that fall inside the Euclidean bounds.
    """
    lattice_points = []
    
    # The corners of the bounding box in Euclidean space
    corners = [
        [xlim[0], ylim[0]],
        [xlim[0], ylim[1]],
        [xlim[1], ylim[0]],
        [xlim[1], ylim[1]],
    ]

    # Map the corners to lattice coordinates
    coords_corners = [np.linalg.solve(B.transpose(), c) for c in corners]

    # Determine min/max in lattice coordinates and expand to integer grid
    min_i = int(np.floor(min(c[0] for c in coords_corners)))
    max_i = int(np.ceil(max(c[0] for c in coords_corners)))
    min_j = int(np.floor(min(c[1] for c in coords_corners)))
    max_j = int(np.ceil(max(c[1] for c in coords_corners)))

    # Generate points and filter to actual Euclidean box
    for i in range(min_i, max_i + 1):
        for j in range(min_j, max_j + 1):
            p = np.array([i, j]) @ B
            if xlim[0] <= p[0] <= xlim[1] and ylim[0] <= p[1] <= ylim[1]:
                lattice_points.append(p)

    return np.array(lattice_points)    

def draw_basis_vectors(B):
    """
    Draw basis vectors.

    Parameters
    ----------
    B : np.ndarray
        2×2 basis matrix (rows are basis vectors).
    """
    b1 = B[0, :]
    b2 = B[1, :]

    arrow_style = dict(
        head_width=0.3,
        head_length=0.3,
        fc="blue", ec="blue",
        length_includes_head=True
    )

    plt.arrow(0, 0, b1[0], b1[1], **arrow_style)
    plt.arrow(0, 0, b2[0], b2[1], **arrow_style)


def draw_fundamental_regions(B, xlim, ylim, color1="lightgray", color2="white", alpha=0.8, outline=True):
    """
    Draw checkerboard-style centered fundamental parallelograms over the given bounds.

    Parameters
    ----------
    B : np.ndarray
        2×2 basis matrix (rows are basis vectors).
    xlim, ylim : tuple
        Horizontal and vertical plot limits in Euclidean coords.
    """
    B = np.asarray(B, dtype=float)

    # Basis vectors (rows)
    b1 = B[0, :]
    b2 = B[1, :]

    # Offsets for the centered fundamental region: ±½ b1 ± ½ b2 (closed loop)
    offsets = np.vstack([
        -0.5*b1 - 0.5*b2,
         0.5*b1 - 0.5*b2,
         0.5*b1 + 0.5*b2,
        -0.5*b1 + 0.5*b2,
        -0.5*b1 - 0.5*b2
    ])

    # Map plot-box corners to lattice coordinates
    box = np.array([
        [xlim[0], ylim[0]],
        [xlim[0], ylim[1]],
        [xlim[1], ylim[0]],
        [xlim[1], ylim[1]],
    ], dtype=float)

    # lattice coords of the 4 corners: solve [i,j] @ B = [x,y]
    box_lat = np.linalg.solve(B.T, box.T).T
    i_min = int(np.floor(box_lat[:, 0].min())) - 1
    i_max = int(np.ceil (box_lat[:, 0].max())) + 1
    j_min = int(np.floor(box_lat[:, 1].min())) - 1
    j_max = int(np.ceil (box_lat[:, 1].max())) + 1

    # Tile cells
    for i in range(i_min, i_max + 1):
        for j in range(j_min, j_max + 1):
            # Center of this cell in Euclidean coordinates
            center = np.array([i, j]) @ B

            # Alternate fill by parity in lattice coords
            color = color1 if ((i + j) % 2 == 0) else color2

            poly = center + offsets
            plt.fill(poly[:, 0], poly[:, 1], color=color, alpha=alpha, zorder=0)
            if outline:
                plt.plot(poly[:, 0], poly[:, 1], color="gray", linewidth=0.6, zorder=1)


