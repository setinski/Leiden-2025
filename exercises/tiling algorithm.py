import numpy as np
import matplotlib.pyplot as plt
from generic_functions import generate_lattice_points, draw_basis_vectors

def tiling_in_Zn(T, t):
    """
    solves P(T)-tiling for the lattice Z^n.

    :param T: A NumPy array of shape (n, n) representing a lower triangular matrix with unit diagonal
    :type Bs: numpy.nnarray
    :param t: A NumPy array of shape (n,) representing the target vector to approximate.
    :type t: numpy.narray

    :return: A lattice vector (as a NumPy array) in Z^n, which is close to the target `t`.
    :rtype: numpy.narray
    """  
    n = np.shape(T)[0]

    if n == 1:
        return np.round(t) # simple rounding in one dimension
    
    v = np.zeros(n)
    v[-1] = np.round(t[-1])
    a = t[-1] - v[-1]

    v[:-1] = tiling_in_Zn(T[:-1,:-1], t[:-1] - a*T[-1][:-1]) # implement recursion
    
    return v

def tiling(B, T, t):
    """
    solves P(T@B)-tiling for the lattice L(B).

    :param B: A NumPy array of shape (n, n) representing the lattice basis.
              Each row of `B` is a basis vector.
    :type B: numpy.nnarray
    :param T: A NumPy array of shape (n, n) representing a lower triangular matrix with unit diagonal
    :type Bs: numpy.nnarray
    :param t: A NumPy array of shape (n,) representing the target vector to approximate.
    :type t: numpy.narray

    :return: A lattice vector (as a NumPy array) in the lattice generated by `B`,
             which is close to the target `t`.
    :rtype: numpy.narray
    """
    # recall: np.linalg.solve(B.T,t) is t @ B^{-1}
    
    return tiling_in_Zn(T,np.linalg.solve(B.T,t)) @ B


B = np.array([[1,0,1],[0,1,0],[1,6,0]])
# T = np.identity(3)
T = np.array([[1,0,0],[2,1,0],[3,2,1]])
t = [1,2.8,3.6]

print(tiling(B, T, t))

### Sanity checks

v = tiling(B, T, t)

# the tiling vector is in the lattice:
x = np.linalg.solve(B.T,v)
print(np.allclose(np.round(x), x))

# the difference between the tiling vector and the target is in the fundamental parallelogram
# x \in [-1/2, 1/2)^n * T@B iff x @ (T@B)^{-1} \in [-1/2, 1/2)^n
C = np.linalg.inv(T @ B).T

for i in range(3):
    print((v-t) @ C[i] < .5 or (v-t) @ C[i] >= -.5)

###--- Visualization ---###

def draw_fundamental_regions(B, T, xlim, ylim, color1="lightgray", color2="white", alpha=0.8, outline=True):
    """
    Draw checkerboard-style centered fundamental parallelograms over the given bounds.

    Parameters
    ----------
    B : np.ndarray
        2×2 basis matrix (rows are basis vectors).
    xlim, ylim : tuple
        Horizontal and vertical plot limits in Euclidean coords.
    """
    B = np.asarray(B, dtype=float)
    B_trans = np.asarray(T @ B, dtype=float)

    # Basis vectors (rows)
    b1 = B_trans[0, :]
    b2 = B_trans[1, :]

    # Offsets for the centered fundamental region: ±½ b1 ± ½ b2 (closed loop)
    offsets = np.vstack([
        -0.5*b1 - 0.5*b2,
         0.5*b1 - 0.5*b2,
         0.5*b1 + 0.5*b2,
        -0.5*b1 + 0.5*b2,
        -0.5*b1 - 0.5*b2
    ])

    # Map plot-box corners to lattice coordinates
    box = np.array([
        [xlim[0], ylim[0]],
        [xlim[0], ylim[1]],
        [xlim[1], ylim[0]],
        [xlim[1], ylim[1]],
    ], dtype=float)

    # lattice coords of the 4 corners: solve [i,j] @ B = [x,y]
    box_lat = np.linalg.solve(B.T, box.T).T
    i_min = int(np.floor(box_lat[:, 0].min())) - 1
    i_max = int(np.ceil (box_lat[:, 0].max())) + 1
    j_min = int(np.floor(box_lat[:, 1].min())) - 1
    j_max = int(np.ceil (box_lat[:, 1].max())) + 1

    # Tile cells
    for i in range(i_min, i_max + 1):
        for j in range(j_min, j_max + 1):
            # Center of this cell in Euclidean coordinates
            center = np.array([i, j]) @ B

            # Alternate fill by parity in lattice coords
            color = color1 if ((i + j) % 2 == 0) else color2

            poly = center + offsets
            plt.fill(poly[:, 0], poly[:, 1], color=color, alpha=alpha, zorder=0)
            if outline:
                plt.plot(poly[:, 0], poly[:, 1], color="gray", linewidth=0.6, zorder=1)


def plot_lattice_scene(B,T, xlim, ylim, t=None, rounding_vec=None, title="", save=False):
    """Draw lattice tiling, points, basis, and optional extras."""
    plt.figure(figsize=(6, 6))

    # Draw background tiling
    draw_fundamental_regions(B, T, xlim, ylim)

    # Draw lattice points
    pts = generate_lattice_points(B, xlim, ylim)
    plt.scatter(pts[:, 0], pts[:, 1], s=20, c="black", zorder=2, label="Lattice points")

    # Draw basis vectors (blue)
    draw_basis_vectors(B)

    # Plot target vector if provided
    plt.scatter(t[0], t[1], c="red", s=30, marker="o", zorder=3, label="Target vector")

    # Plot rounding result if provided
    if rounding_vec is not None:
        plt.scatter(rounding_vec[0], rounding_vec[1], c="orange", s=80, marker="x", zorder=3, label="Obtained approximation")

    plt.xlim(xlim)
    plt.ylim(ylim)
    plt.gca().set_aspect("equal", adjustable="box")
    plt.title(title)
    plt.legend()

    if save:
        global save_counter
        filename = f"Lattice_{B.shape[0]}_{save_counter}.png"
        plt.savefig(filename)
        save_counter += 1
    else:
        plt.show()

    plt.clf()
    plt.close()

############
# Main runner
############
if __name__ == "__main__":
    # Example bases
    bases = [
        np.array([[4, 0], [1, 4]], dtype=int),
        np.array([[0, 4], [4, 2]], dtype=int)
    ]

    T = np.array([[1,0],[2,1]])
    #T = np.identity(2)

    #print(bases[1] @ T)

    # Example target vector
    t = np.array([3.3, 8.4], dtype=float)

    # Plot limits
    xlim, ylim = (-13, 13), (-13, 13)

    ##### Check if vector is in lattice #####
    #print("\n=== Check if vector is in lattice ===")
    
    ##### plot tiling #####
    for B in bases:
        plot_lattice_scene(B, T, xlim, ylim, t=t, rounding_vec=tiling(B, T, t),title="Slanted tiling")
        
    input("Press Enter to continue...")

